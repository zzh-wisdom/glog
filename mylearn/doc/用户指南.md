# User Guide

原文：<https://github.com/zzh-wisdom/glog#user-guide>

- [1. 严重级别 Severity Levels](#1-严重级别-severity-levels)
- [2. Setting Flags](#2-setting-flags)
- [3. 条件/偶尔记录](#3-条件偶尔记录)
- [4. 调试模式支持](#4-调试模式支持)
- [5. CHECK Macros](#5-check-macros)
- [6. 详细记录](#6-详细记录)
- [7. 自定义日志前缀格式](#7-自定义日志前缀格式)
- [8. 故障信号处理程序](#8-故障信号处理程序)
- [9. 消息性能](#9-消息性能)
- [10. 用户定义的失败函数](#10-用户定义的失败函数)
- [11. 原始记录](#11-原始记录)
- [12. 谷歌风格 perror()](#12-谷歌风格-perror)
- [13. 系统日志](#13-系统日志)
- [14. Strip Logging Messages](#14-strip-logging-messages)
- [15. 自动删除旧日志](#15-自动删除旧日志)
- [16. Windows 用户注意事项](#16-windows-用户注意事项)

glog定义了很多宏以简化常用的log任务。您可以：

- 按不同严重级别记录log消息
- 从命令行控制日志记录行为
- 基于条件记录log、在不满足预期条件时中止程序
- **引入自定义的详细log记录级别**
- 自定义附加到日志消息的**前缀**等等

说明：此文档并不完整，仅限于最有用的描述。如果您想查找不太常见的功能，请检查[src/glog](https://github.com/zzh-wisdom/glog/blob/master/src/glog)目录下的头文件。

> 推荐：
>
> 1. 使用调试模式下的宏，如 DLOG，DVLOG等，可以通过 NDEBUG进行屏蔽
> 2. RAW_VLOG  但只能打印到 stderr（考虑采用重定向）
> 3. PLOG()and 和PLOG_IF()and 的PCHECK()
> 4. 简单使用参考：<https://zhuanlan.zhihu.com/p/99552958>
>

## 1. 严重级别 Severity Levels

严重性级别有以下几种（按照严重性递增的顺序）：

- INFO
- WARNING
- ERROR
- FATAL

记录FATAL消息会**终止程序**（在记录消息之后）

> 请注意，给定严重性的消息不仅会记录在该严重性的日志文件中，还会记录在所有**较低严重性的日志文件中**。例如，严重程度FATAL的信息将被记录到严重程度为FATAL，ERROR，WARNING，和INFO的日志文件中。

在没有 `NDEBUG` 宏定义的情况下，严重性级别 `DFATAL` 会在debug模式下记录一个 `FATAL` 错误，并通过降级为 `ERROR` 严重性来避免在生产环境下终止程序。（即DFATAL是一个特殊的严重性级别）

**日志路径**：除非指定其他路径，否则glog将日志记录到文件 `/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>`，例如 /tmp/hello_world.example.com.hamaji.log.INFO.20080709-222411.10474。
默认情况下，严重性级别为 ERROR 和 FATAL 的日志除了记录到log文件外，还会被拷贝到标准错误输出。

## 2. Setting Flags

几个标志会影响 glog 的输出行为。如果您的机器上安装了 Google gflags 库，构建系统将自动检测并使用它，允许您在命令行上传递标志。例如，如果您想打开该标志`--logtostderr`，您可以使用以下命令行启动您的应用程序：

```shell
./your_application --logtostderr=1
```

如果未安装 Google gflags 库，您可以通过环境变量设置标志，在标志名称前加上前缀GLOG_，例如，

```shell
GLOG_logtostderr=1 ./your_application
```

以下标志是最常用的：

- **`logtostderr`**(bool, 默认=false)
  将消息记录到stderr而不是日志文件。注意：您可以设置二进制标志，通过指定`1`，`true`或`yes`（不区分大小写）来表示`true`。此外，您可以通过指定0, false, 或no（同样不区分大小写）来设置`false`。
- **`stderrthreshold`**(int, 默认=2, 即ERROR)
  除了记录到日志文件之外，将处于或高于此级别的日志消息复制到 `stderr`。INFO、WARNING、 ERROR和 FATAL的严重性级别分别为 0、 1、 2 和 3。
- **`minloglevel`**(int, 默认=0, 即INFO)
  记录处于或高于此级别的消息。同样，INFO、WARNING、ERROR和FATAL的严重性级别分别为 0、1、2 和 3。
- **`log_dir`**（string，默认=“”）
 如果指定，日志将写入此目录而不是默认日志目录。
- **`v`**(int, 默认=0)
  显示m小于或等于此标志值的所有 `VLOG(m)` 消息。由被`--vmodule`标志覆盖。有关详细信息，请参阅有关[详细日志记录](https://github.com/zzh-wisdom/glog#verbose-logging)的部分。
- **`vmodule`**（string，默认=“”）
  每个模块的详细级别。该参数必须包含**以逗号分隔的 `<module name>=<log level>` 列表**。<module name> 是一个 glob 模式（例如，`gfs*`匹配名称以“gfs”开头的所有模块）、与文件名基础匹配（即忽略 `.cc/.h./-inl.h` 的名称）。`<log level>` 覆盖由 `--v` 给出的任何值。另请参阅有关[详细日志记录](https://github.com/zzh-wisdom/glog#verbose-logging)的部分。

> Glob Patterns匹配模式使用: <https://zhuanlan.zhihu.com/p/53888457>

[logging.cc](/src/logging.cc) 中还定义了一些其他标志。请grep源代码以查看所有DEFINE_标志的完整列表。

你还可以在程序中修改flag，通过修改全局变量 `FLAGS_*`。大多数设置会在你更改 `FLAGS_*` 后立即生效，例外的是与文件目标相关的标志。例如，您可能需要在调用`google::InitGoogleLogging`之前设置`FLAGS_log_dir`。下面是一个例子：

```cpp
LOG(INFO) << "file";
// Most flags work immediately after updating values.
FLAGS_logtostderr = 1;
LOG(INFO) << "stderr";
FLAGS_logtostderr = 0;
// This won’t change the log destination. If you want to set this
// value, you should do this before google::InitGoogleLogging .
FLAGS_log_dir = "/some/log/directory";
LOG(INFO) << "the same file";
```

## 3. 条件/偶尔记录

有时，您可能只想在特定条件下记录消息。您可以使用以下宏来执行条件日志记录：

```cpp
LOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
```

仅当变量num_cookies超过 10时才会记录“Got lot of cookies”消息 。

如果一行代码被多次执行，则仅以特定时间间隔记录一条消息可能会很有用。这种日志记录对于信息性消息最有用。

```cpp
LOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th cookie";
```

上面的行在第 1、11、21、... 次执行时输出日志消息。请注意，特殊值 `google::COUNTER` 用于标识正在发生的重复过程的次数。

您可以将条件记录和偶尔记录结合使用。

```cpp
LOG_IF_EVERY_N(INFO, (size > 1024), 10) << "Got the " << google::COUNTER
                                        << "th big cookie";
```

除了每 n 次输出一条消息，您还可以将输出限制为前 n 次出现：

```cpp
LOG_FIRST_N(INFO, 20) << "Got the " << google::COUNTER << "th cookie";
```

其他时候，只希望根据时间定期记录消息。例如，每 10 毫秒记录一条消息：

```cpp
LOG_EVERY_T(INFO, 0.01) << "Got a cookie";
```

或者每 2.35 秒：

```cpp
LOG_EVERY_T(INFO, 2.35) << "Got a cookie";
```

## 4. 调试模式支持

> 普通的 LOG 在非debug环境也会打印日志

特殊的“调试模式”日志宏仅在调试模式下有效，并且在非调试模式编译时被编译为空。使用这些宏可以避免由于过多的日志记录而减慢生产应用程序的速度。

```cpp
DLOG(INFO) << "Found cookies";
DLOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
DLOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th cookie";
```

## 5. CHECK Macros

> 由于CHECK不受 `NDEBUG` 宏控制，因此建议改用标准库的 assert。具体原理参考：<https://blog.csdn.net/z1026544682/article/details/103871124>

经常检查程序中的预期条件以尽早发现错误是一种很好的做法。该CHECK宏提供了在不满足条件时中止应用程序的能力，类似于标准 C 库中定义的assert宏。

CHECK如果条件不成立，则中止应用程序。与 assert 不同，它*不受* NDEBUG 控制，因此无论编译模式如何，都将执行检查。因此，fp->Write(x)在以下示例中始终执行：

```cpp
CHECK(fp->Write(x) == 4) << "Write failed!";
```

有相等/不相等等各种辅助检查宏-CHECK_EQ，CHECK_NE，CHECK_LE，CHECK_LT，CHECK_GE和CHECK_GT。它们比较两个值，并在结果不符合预期时记录包含这两个值的FATAL消息。这些值必须已定义operator<<(ostream, ...)。

您可以像这样附加到错误消息：

```cpp
CHECK_NE(1, 2) << ": The world must be ending!";
```

我们非常小心地确保每个参数只计算一次（即只执行一次），并且任何合法作为函数参数传递的东西在这里都是合法的。特别是，参数可能是临时表达式，最终会在显式语句的末尾被销毁，例如：

```cpp
CHECK_EQ(string("abc")[1], ’b’);
```

如果参数之一是指针而另一个是NULL，则编译器会报告错误。要解决此问题，只需static_cast NULL指向所需指针的类型即可。

```cpp
CHECK_EQ(some_ptr, static_cast<SomeType*>(NULL));
```

更好的是，使用CHECK_NOTNULL宏：

```cpp
CHECK_NOTNULL (some_ptr);
some_ptr-> DoSomething ();
```

由于这个宏返回给定的指针，这在构造函数初始值设定项列表中非常有用。

```cpp
struct S {
    S(Something* ptr) : ptr_(CHECK_NOTNULL(ptr)) {}
    Something* ptr_;
};
```

请注意，由于此功能（返回指针），您不能将此宏用作 C++ 流。在中止应用程序之前，请改用上述的CHECK_EQ宏来记录自定义消息。

如果您比较C字符串（char *），一组实用宏执行大小写敏感以及不区分大小写的比较-CHECK_STREQ， CHECK_STRNE，CHECK_STRCASEEQ和CHECK_STRCASENE。CASE版本不区分大小写。您可以安全地将NULL为此宏传递指针。他们将NULL和 任何非NULL字符串视为不相等。两个NULL是相等的。

请注意，两个参数都可能是临时字符串，它们在当前“完整表达式”（例如，CHECK_STREQ(Foo().c_str(), Bar().c_str()) where Foo和Bar return C++'s std::string）的末尾被破坏 。

CHECK_DOUBLE_EQ检查两个浮点值是否相等，并接受一个小的误差裕度。CHECK_NEAR接受第三个浮点参数，它指定可接受的误差范围。

## 6. 详细记录

当您在追查困难的错误时，完整的日志消息非常有用。但是，您可能希望在通常的开发中忽略过于冗长的消息。对于这种详细的日志记录，glog 提供了 VLOG 宏，它允许您定义自己的数字日志记录级别。该详细的消息受命令行选项--v的控制：

```cpp
VLOG(1) << "I’m printed when you run the program with --v=1 or higher";
VLOG(2) << "I’m printed when you run the program with --v=2 or higher";
```

使用VLOG，详细级别越低，记录消息的可能性就越大。例如，如果--v==1, VLOG(1)将记录，但VLOG(2) 不会记录。这与严重性级别相反，其中INFO为 0，ERROR为 2。--minloglevel=1将记录WARNING及以上的log。尽管您可以为VLOG宏和--v标志指定任何整数，但它们的公共值是**小的正整数**。例如，如果您编写 VLOG(0)，则应指定--v=-1或更低以使其静音。**这不太有用，因为在大多数情况下我们可能不需要默认的详细日志**。该 VLOG 宏总是按照INFO日志级别记录log。

可以在每个模块的基础上从命令行控制详细日志记录：

```cpp
--vmodule=mapreduce=2,file=1,gfs*=3 --v=0
```

1. Print VLOG(2) and lower messages from mapreduce.{h,cc}
2. Print VLOG(1) and lower messages from file.{h,cc}
3. Print VLOG(3) and lower messages from files prefixed with "gfs"
4. Print VLOG(0) and lower messages from elsewhere

(c) 所示的通配符功能支持 '*'（匹配 0 个或多个字符）和 '?' （匹配任何单个字符）通配符。另请检查有关[命令行标志](https://github.com/zzh-wisdom/glog#setting-flags)的部分。

还有VLOG_IS_ON(n)“详细级别”条件宏。当--v等于或大于n时，此宏返回真。

```cpp
if (VLOG_IS_ON(2)) {
    // do some logging preparation and logging
    // that can’t be accomplished with just VLOG(2) << ...;
}
```

详细级别条件宏VLOG_IF，VLOG_EVERY_N 和 VLOG_IF_EVERY_N行为类似于LOG_IF, LOG_EVERY_N, LOF_IF_EVERY，但接受数字详细级别而不是严重性级别。

```cpp
VLOG_IF(1, (size > 1024))
   << "I’m printed when size is more than 1024 and when you run the "
      "program with --v=1 or more";
VLOG_EVERY_N(1, 10)
   << "I’m printed every 10th occurrence, and when you run the program "
      "with --v=1 or more. Present occurence is " << google::COUNTER;
VLOG_IF_EVERY_N(1, (size > 1024), 10)
   << "I’m printed on every 10th occurence of case when size is more "
      " than 1024, when you run the program with --v=1 or more. ";
      "Present occurence is " << google::COUNTER;
```

## 7. 自定义日志前缀格式

glog 支持通过接收用户提供的用于生成此类字符串的回调来更改附加到日志消息的前缀的格式。该功能必须在编译时由`WITH_CUSTOM_PREFIX`标志启用。

**对于每个日志条目，回调将被调用，并传递LogMessageInfo结构体**，该结构体包含严重性、文件名、行号、线程 ID 和事件时间。它还将获得对输出流的引用，其内容将被添加到最终日志行中的实际消息之前。

例如：

```cpp
/* This function writes a prefix that matches glog's default format.
 * (The third parameter can be used to receive user-supplied data, and is
 * NULL by default.)
 */
void CustomPrefix(std::ostream &s, const LogMessageInfo &l, void*) {
   s << l.severity[0]
   << setw(4) << 1900 + l.time.year()
   << setw(2) << 1 + l.time.month()
   << setw(2) << l.time.day()
   << ' '
   << setw(2) << l.time.hour() << ':'
   << setw(2) << l.time.min()  << ':'
   << setw(2) << l.time.sec() << "."
   << setw(6) << l.time.usec()
   << ' '
   << setfill(' ') << setw(5)
   << l.thread_id << setfill('0')
   << ' '
   << l.filename << ':' << l.line_number << "]";
}
```

为了能够使用的CustomPrefix()，简单地给出入记录初始化过程中它的指针：`InitGoogleLogging(argv[0], &CustomPrefix);`。

可选地，InitGoogleLogging()将第三个参数传递给回调函数的void*类型参数。

## 8. 故障信号处理程序

该库提供一个方便的信号处理程序，当程序崩溃在某些信号（如 SIGSEGV）上时，该处理程序将转储有用的信息。
信号处理器可以通过 `google::InstallFailureSignalHandler()`。以下是信号处理器输出的示例。

```shell
*** Aborted at 1225095260 (unix time) try "date -d @1225095260" if you are using GNU date ***
*** SIGSEGV (@0x0) received by PID 17711 (TID 0x7f893090a6f0) from PID 0; stack trace: ***
PC: @           0x412eb1 TestWaitingLogSink::send()
    @     0x7f892fb417d0 (unknown)
    @           0x412eb1 TestWaitingLogSink::send()
    @     0x7f89304f7f06 google::LogMessage::SendToLog()
    @     0x7f89304f35af google::LogMessage::Flush()
    @     0x7f89304f3739 google::LogMessage::~LogMessage()
    @           0x408cf4 TestLogSinkWaitTillSent()
    @           0x4115de main
    @     0x7f892f7ef1c4 (unknown)
    @           0x4046f9 (unknown)
```

默认情况下，信号处理程序将故障转储写入标准错误。您可以通过InstallFailureWriter()自定义目的地。

## 9. 消息性能

glog 提供的条件日志宏（例如 CHECK、 LOG_IF、VLOG等）经过精心实施，当条件为假时不会执行右侧表达式。因此，以下检查可能不会牺牲应用程序的性能。

```cpp
codeCHECK(obj.ok) << obj.CreatePrettyFormattedStringButVerySlow();
```

## 10. 用户定义的失败函数

FATAL严重级别消息或不满足的CHECK条件终止您的程序。您可以通过 InstallFailureFunction 更改终止的行为。

```cpp
void YourFailureFunction() {
  // Reports something...
  exit(1);
}

int main(int argc, char* argv[]) {
  google::InstallFailureFunction(&YourFailureFunction);
}
```

默认情况下，glog 会尝试转储堆栈跟踪并使程序以状态 1 退出。仅当您在 glog 支持堆栈跟踪的架构上运行程序时才会生成堆栈跟踪（截至 2008 年 9 月，glog 支持 x86 和 x86_64 的堆栈跟踪）

## 11. 原始记录

头文件`<glog/raw_logging.h>`可用于线程安全日志记录，它不分配任何内存或获取任何锁。因此，这个头文件中定义的宏可以被低级内存分配和同步代码使用。详情请查看[src/glog/raw_logging.h.in](https://github.com/zzh-wisdom/glog/blob/master/src/glog/raw_logging.h.in)。

## 12. 谷歌风格 perror()

PLOG()and 和PLOG_IF()and 的PCHECK()行为与它们的LOG*和CHECK等价物完全一样 ，除了它们**将 errno 的当前状态的描述**附加到它们的输出行之外。例如

```cpp
PCHECK(write(1, NULL, 2) >= 0) << "Write NULL failed";
```

此检查失败并显示以下错误消息。

```shell
F0825 185142 test.cc:22] Check failed: write(1, NULL, 2) >= 0 Write NULL failed: Bad address [14]
```

## 13. 系统日志

SYSLOG、SYSLOG_IF和SYSLOG_EVERY_N宏可用。除了正常日志之外，这些日志还记录到 syslog。请注意，将日志记录到 syslog 会极大地影响性能，尤其是在将 syslog 配置为远程日志记录的情况下！在使用这些宏之前，请确保您了解输出到 syslog 的含义。一般来说，谨慎使用这些宏是明智的。

## 14. Strip Logging Messages

日志消息中使用的字符串会增加二进制文件的大小并带来隐私问题。因此，您可以使用GOOGLE_STRIP_LOG宏命令指示 glog 删除所有低于特定严重性级别的字符串 ：

如果您的应用程序有这样的代码：

```cpp
#define GOOGLE_STRIP_LOG 1    // this must go before the #include!
#include <glog/logging.h>
```

编译器将删除严重性小于指定整数值的日志消息。由于VLOG日志处于严重级别 INFO（数值0），因此设置GOOGLE_STRIP_LOG为 1 或更高会删除与VLOG 关联的所有日志消息以及 INFO 日志语句。

## 15. 自动删除旧日志

要启用日志清理器：

```cpp
google::EnableLogCleaner(3); // keep your logs for 3 days
```

然后 glog 会在执行刷新时检查是否有过期日志。在此示例中，您项目中上次修改时间超过 3 天的任何日志文件都将取消链接()。

可以随时禁用此功能（如果已启用）

```cpp
google::DisableLogCleaner();
```

## 16. Windows 用户注意事项

。。
